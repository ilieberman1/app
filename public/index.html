<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Highway Racing Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #scoreboard {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 20px;
            color: black;
            background-color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <!-- Include Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <div id="scoreboard">Score: 0</div>
    <script>
        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xadd8e6); // Light blue background

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 10, 10);
        scene.add(directionalLight);

        // Create the road
        const roadGeometry = new THREE.PlaneGeometry(10, 200);
        const roadMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2; // Lay flat
        road.position.z = 0;
        scene.add(road);

        // Barriers (left and right)
        const barrierMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const leftBarrier = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, 200), barrierMaterial);
        const rightBarrier = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, 200), barrierMaterial);

        leftBarrier.position.set(-5.25, 0.5, 0);
        rightBarrier.position.set(5.25, 0.5, 0);
        scene.add(leftBarrier, rightBarrier);

        // Create the player car
        const playerCar = createCar(0xff0000);
        playerCar.position.set(0, 0.5, 5); // Start position
        scene.add(playerCar);

        // Create light green trees on the sides
        const trees = [];
        const treeGeometry = new THREE.CylinderGeometry(0, 0.5, 1.5, 8);
        const treeMaterial = new THREE.MeshPhongMaterial({ color: 0x228b22 }); // Green color

        for (let i = 0; i < 100; i++) {
            const tree = new THREE.Mesh(treeGeometry, treeMaterial);
            tree.position.set(
                Math.random() > 0.5 ? 6 + Math.random() * 4 : -6 - Math.random() * 4,
                0.75,
                Math.random() * 400 - 200
            );
            trees.push(tree);
            scene.add(tree);
        }

        // Function to create a car
        function createCar(color) {
            const carGroup = new THREE.Group();

            // Main body
            const bodyGeometry = new THREE.BoxGeometry(1.5, 0.5, 3);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            carGroup.add(body);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 32);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const wheels = [];
            for (let i = 0; i < 4; i++) {
                wheels[i] = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheels[i].rotation.z = Math.PI / 2; // Rotate to lay flat
            }
            wheels[0].position.set(-0.7, 0.3, 1.3); // Front-left
            wheels[1].position.set(0.7, 0.3, 1.3); // Front-right
            wheels[2].position.set(-0.7, 0.3, -1.3); // Back-left
            wheels[3].position.set(0.7, 0.3, -1.3); // Back-right

            wheels.forEach((wheel) => carGroup.add(wheel));

            return carGroup;
        }

        // Traffic cars
        const trafficCars = [];
        for (let i = 0; i < 10; i++) {
            const trafficCar = createCar(0x0000ff); // Blue traffic cars
            trafficCar.position.set(
                (Math.random() - 0.5) * 8, // Random x-position within road
                0.5,
                Math.random() * -200 + 50
            );
            trafficCar.userData.speed = 0.2 + Math.random() * 0.1; // Assign a random speed
            trafficCars.push(trafficCar);
            scene.add(trafficCar);
        }

        // Variables
        let score = 0;
        let gameOver = false;
        let playerSpeed = 0;
        const maxSpeed = 0.5; // Max speed for acceleration
        const acceleration = 0.01; // Acceleration rate
        const deceleration = 0.02; // Deceleration rate

        // Update score
        const scoreboard = document.getElementById('scoreboard');

        // Animation loop
        function animate() {
            if (gameOver) return;

            requestAnimationFrame(animate);

            // Move traffic cars towards the player
            trafficCars.forEach((trafficCar) => {
                trafficCar.position.z += trafficCar.userData.speed; // Traffic cars move towards the player

                if (trafficCar.position.z > playerCar.position.z + 20) {
                    trafficCar.position.z = playerCar.position.z - 200; // Reset position
                    trafficCar.position.x = (Math.random() - 0.5) * 8; // Random x
                }

                // Collision detection
                if (
                    Math.abs(playerCar.position.x - trafficCar.position.x) < 1.5 &&
                    Math.abs(playerCar.position.z - trafficCar.position.z) < 3
                ) {
                    gameOver = true;
                    alert('Game Over!');
                }
            });

            // Loop trees for infinite scrolling
            trees.forEach((tree) => {
                tree.position.z += 0.2; // Move towards player
                if (tree.position.z > playerCar.position.z + 20) {
                    tree.position.z = playerCar.position.z - 200; // Reset position
                }
            });

            // Enforce road boundaries
            if (playerCar.position.x < -4.5) playerCar.position.x = -4.5;
            if (playerCar.position.x > 4.5) playerCar.position.x = 4.5;

            // Update camera position (fixed behind the player)
            camera.position.set(playerCar.position.x, 5, playerCar.position.z + 10);
            camera.lookAt(playerCar.position);

            // Update score
            score += 1;
            scoreboard.textContent = `Score: ${score}`;

            renderer.render(scene, camera);
        }

        animate();

        // Handle keyboard input
        const keys = {};
        document.addEventListener('keydown', (event) => {
            keys[event.key] = true;
        });
        document.addEventListener('keyup', (event) => {
            keys[event.key] = false;
        });

        // Update player car based on keys
        function handleInput() {
            // Move left/right
            if (keys['ArrowLeft']) playerCar.position.x -= 0.15;
            if (keys['ArrowRight']) playerCar.position.x += 0.15;

            // Enforce road boundaries immediately after movement
            if (playerCar.position.x < -4.5) playerCar.position.x = -4.5;
            if (playerCar.position.x > 4.5) playerCar.position.x = 4.5;

            // Move forward/backward with acceleration/deceleration
            if (keys['ArrowUp']) {
                playerSpeed = Math.min(playerSpeed + acceleration, maxSpeed);
            } else if (keys['ArrowDown']) {
                playerSpeed = Math.max(playerSpeed - acceleration, -maxSpeed / 2); // Allow reverse
            } else {
                // No key pressed, decelerate to 0
                if (playerSpeed > 0) {
                    playerSpeed = Math.max(playerSpeed - deceleration, 0);
                } else if (playerSpeed < 0) {
                    playerSpeed = Math.min(playerSpeed + deceleration, 0);
                }
            }

            // Update player car position
            playerCar.position.z -= playerSpeed;

            setTimeout(handleInput, 16);
        }
        handleInput();
    </script>
</body>
</html>