<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Highway Racing Game</title>
    <style>
        /* Your existing CSS code */
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #scoreboard {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 20px;
            color: black;
            background-color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            z-index: 1;
        }
        #subtitle {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-40%);
            color: black;
            font-family: Arial, sans-serif;
            font-size: 48px;
            font-weight: bold;
            text-align: left;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
            text-shadow: 
                -2px -2px 0 white,
                2px -2px 0 white,
                -2px 2px 0 white,
                2px 2px 0 white;
            width: 80%;
            line-height: 1.2;
            z-index: 1;
        }
        /* Main Menu Styles */
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #add8e6;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }
        #game-title {
            font-size: 48px;
            margin-bottom: 40px;
            font-family: Arial, sans-serif;
            color: black;
        }
        #car-images {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 40px;
        }
        .car-image {
            width: 100px;
            height: 50px;
            margin: 0 50px;
            position: relative;
            background-color: transparent;
        }
        /* Car Shape Styles */
        .car-body {
            width: 100px;
            height: 30px;
            background-color: currentColor;
            position: relative;
            border-radius: 5px;
        }
        .car-top {
            width: 60px;
            height: 20px;
            background-color: currentColor;
            position: absolute;
            top: -20px;
            left: 20px;
            border-radius: 5px 5px 0 0;
        }
        .wheel {
            width: 20px;
            height: 20px;
            background-color: black;
            border-radius: 50%;
            position: absolute;
            bottom: -10px;
        }
        .wheel.left {
            left: 15px;
        }
        .wheel.right {
            right: 15px;
        }
        /* Cop car styles */
        #cop-car .car-body,
        #cop-car .car-top {
            color: blue;
        }
        /* User car styles */
        #user-car .car-body,
        #user-car .car-top {
            color: red;
        }
        #start-button {
            font-size: 36px;
            padding: 15px 30px;
            margin-bottom: 20px;
            cursor: pointer;
        }
        #settings-button {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 18px;
            padding: 10px 20px;
            cursor: pointer;
        }
        /* Loading Screen Styles */
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3;
            display: none; /* Hidden initially */
        }
    </style>
    <!-- Import map to resolve module specifiers -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.152.0/build/three.module.js",
            "three/examples/jsm/loaders/FBXLoader.js": "https://unpkg.com/three@0.152.0/examples/jsm/loaders/FBXLoader.js",
            "three/examples/jsm/objects/Sky.js": "https://unpkg.com/three@0.152.0/examples/jsm/objects/Sky.js",
            "gsap": "https://unpkg.com/gsap@3.11.4/index.js"
        }
    }
    </script>
</head>
<body>
    <!-- Main Menu -->
    <div id="main-menu">
        <h1 id="game-title">Escape the Cop</h1>
        <div id="car-images">
            <div id="cop-car" class="car-image">
                <div class="car-body"></div>
                <div class="car-top"></div>
                <div class="wheel left"></div>
                <div class="wheel right"></div>
            </div>
            <div id="user-car" class="car-image">
                <div class="car-body"></div>
                <div class="car-top"></div>
                <div class="wheel left"></div>
                <div class="wheel right"></div>
            </div>
        </div>
        <!-- Disable the Start button initially -->
        <button id="start-button" disabled>Start</button>
        <button id="settings-button">Settings</button>
    </div>
    <div id="scoreboard">Score: 0</div>
    <div id="subtitle"></div>
    <div id="loading-screen">Loading... 0%</div>

    <!-- Your JavaScript code -->
    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';
        import { Sky } from 'three/examples/jsm/objects/Sky.js';
        import gsap from 'gsap';

        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();

        // Set the background color to light sky blue
        scene.background = new THREE.Color(0x87ceeb); // Light blue background

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        // Add a sun (Directional Light)
        const sun = new THREE.DirectionalLight(0xffddaa, 1);
        sun.position.set(-50, 100, -50);
        scene.add(sun);

        // Sun object for visual representation
        const sunGeometry = new THREE.SphereGeometry(5, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffddaa });
        const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
        sunMesh.position.copy(sun.position);
        scene.add(sunMesh);

        // Optional: Add a procedural sky
        function createProceduralSky() {
            const sky = new Sky();
            sky.scale.setScalar(450000);
            scene.add(sky);

            const skyUniforms = sky.material.uniforms;

            skyUniforms['turbidity'].value = 10;
            skyUniforms['rayleigh'].value = 2;
            skyUniforms['mieCoefficient'].value = 0.005;
            skyUniforms['mieDirectionalG'].value = 0.8;

            const sunParameters = {
                elevation: 20,
                azimuth: 180
            };

            const phi = THREE.MathUtils.degToRad(90 - sunParameters.elevation);
            const theta = THREE.MathUtils.degToRad(sunParameters.azimuth);

            sun.position.setFromSphericalCoords(1, phi, theta);

            sky.material.uniforms['sunPosition'].value.copy(sun.position);
        }
        createProceduralSky();

        // Define road parameters
        const roadWidth = 10;
        const roadLength = 20000; // Road length

        // Create the road
        const roadGeometry = new THREE.PlaneGeometry(roadWidth, roadLength);
        const roadMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2; // Lay flat
        road.position.z = 0; // Centered at z = 0
        scene.add(road);

        // Add highway lines
        function createHighwayLines() {
            const lineGroup = new THREE.Group();
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const lineWidth = 0.1;
            const lineLength = 5;
            const gapBetweenLines = 5;
            const numberOfLines = Math.ceil(roadLength / (lineLength + gapBetweenLines));
            const lanePositions = [-roadWidth / 4, 0, roadWidth / 4];

            lanePositions.forEach((xPos) => {
                for (let i = 0; i < numberOfLines; i++) {
                    const lineGeometry = new THREE.PlaneGeometry(lineWidth, lineLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(xPos, 0.01, -roadLength / 2 + i * (lineLength + gapBetweenLines));
                    lineGroup.add(line);
                }
            });
            scene.add(lineGroup);
        }
        createHighwayLines();

        // Add barriers
        function createBarriers() {
            const barrierGroup = new THREE.Group();
            const barrierGeometry = new THREE.BoxGeometry(0.2, 1, 5);
            const barrierMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const numberOfBarriers = Math.ceil(roadLength / 5);
            const positions = [-roadWidth / 2 - 0.5, roadWidth / 2 + 0.5];

            positions.forEach((xPos) => {
                for (let i = 0; i < numberOfBarriers; i++) {
                    const barrier = new THREE.Mesh(barrierGeometry, barrierMaterial);
                    barrier.position.set(xPos, 0.5, -roadLength / 2 + i * 5);
                    barrierGroup.add(barrier);
                }
            });
            scene.add(barrierGroup);
        }
        createBarriers();

        // Loading Screen Elements
        const loadingScreen = document.getElementById('loading-screen');
        const mainMenu = document.getElementById('main-menu');
        const startButton = document.getElementById('start-button');

        // Show loading screen
        loadingScreen.style.display = 'flex';

        // Create the player car (Porsche model)
        const fbxLoader = new FBXLoader();
        let playerCar;
        let modelLoaded = false;

        fbxLoader.load(
            'porsche.fbx', // Adjust path as needed
            (object) => {
                playerCar = object;

                // Adjust scale to match traffic cars
                playerCar.scale.set(0.02, 0.02, 0.02); // Increased scale

                // Adjust position to sit on the road
                playerCar.position.set(0, 0.5, 0); // Adjusted Y position

                // Adjust rotation if necessary
                //playerCar.rotation.y = Math.PI; // Rotate 180 degrees if model faces backward

                scene.add(playerCar);
                modelLoaded = true;

                // Enable Start button and hide loading screen
                startButton.disabled = false;
                loadingScreen.style.display = 'none';
                mainMenu.style.display = 'flex';
            },
            // Progress function
            (xhr) => {
                if (xhr.lengthComputable) {
                    const percentComplete = (xhr.loaded / xhr.total) * 100;
                    console.log(`Loading model: ${Math.round(percentComplete)}%`);
                    loadingScreen.textContent = 'Loading... ' + Math.round(percentComplete) + '%';
                }
            },
            // Error function
            (error) => {
                console.error('Error loading the Porsche model:', error);
                loadingScreen.textContent = `Error loading model: ${error.message}. Please check the file path.`;
            }
        );

        // Create the cop car
        function createCar(color) {
            const carGroup = new THREE.Group();

            // Main body
            const bodyGeometry = new THREE.BoxGeometry(1.5, 0.5, 3);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            carGroup.add(body);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 32);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const wheels = [];
            for (let i = 0; i < 4; i++) {
                wheels[i] = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheels[i].rotation.z = Math.PI / 2; // Rotate to lay flat
            }
            wheels[0].position.set(-0.7, 0.3, 1.3); // Front-left
            wheels[1].position.set(0.7, 0.3, 1.3); // Front-right
            wheels[2].position.set(-0.7, 0.3, -1.3); // Back-left
            wheels[3].position.set(0.7, 0.3, -1.3); // Back-right

            wheels.forEach((wheel) => carGroup.add(wheel));

            return carGroup;
        }

        const copCar = createCar(0x0000ff); // Blue cop car
        copCar.position.set(0, 0.5, -15); // Start closer behind the player
        scene.add(copCar);

        // Add siren light to the cop car
        const siren = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 0.2, 0.2),
            new THREE.MeshBasicMaterial({ color: 0x000000 })
        );
        siren.position.set(0, 1, 0);
        copCar.add(siren);

        // Create trees on the sides
        const trees = [];
        const treeGeometry = new THREE.ConeGeometry(0.5, 2, 8);
        const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
        const treeMaterial = new THREE.MeshPhongMaterial({ color: 0x228b22 }); // Green color
        const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 }); // Brown color

        for (let i = 0; i < 500; i++) {
            const tree = new THREE.Group();

            const leaves = new THREE.Mesh(treeGeometry, treeMaterial);
            leaves.position.y = 1.5;
            tree.add(leaves);

            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.5;
            tree.add(trunk);

            tree.position.set(
                Math.random() > 0.5 ? roadWidth / 2 + 2 + Math.random() * 10 : -roadWidth / 2 - 2 - Math.random() * 10,
                0,
                -roadLength / 2 + Math.random() * roadLength
            );
            trees.push(tree);
            scene.add(tree);
        }

        // Add distant mountains
        function createMountains() {
            const mountainGeometry = new THREE.ConeGeometry(50, 100, 32);
            const mountainMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
            const mountainLeft = new THREE.Mesh(mountainGeometry, mountainMaterial);
            const mountainRight = new THREE.Mesh(mountainGeometry, mountainMaterial);

            mountainLeft.position.set(-100, -50, -200);
            mountainRight.position.set(100, -50, -200);

            scene.add(mountainLeft, mountainRight);
        }
        createMountains();

        // Add clouds
        function createClouds() {
            const cloudGeometry = new THREE.SphereGeometry(5, 32, 32);
            const cloudMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            for (let i = 0; i < 50; i++) {
                const cloud = new THREE.Group();

                const puff1 = new THREE.Mesh(cloudGeometry, cloudMaterial);
                const puff2 = new THREE.Mesh(cloudGeometry, cloudMaterial);
                const puff3 = new THREE.Mesh(cloudGeometry, cloudMaterial);

                puff1.position.set(-2, 0, 0);
                puff2.position.set(2, 0, 0);
                puff3.position.set(0, 1.5, 0);

                cloud.add(puff1);
                cloud.add(puff2);
                cloud.add(puff3);

                cloud.scale.setScalar(1 + Math.random() * 2);
                cloud.position.set(
                    -200 + Math.random() * 400,
                    30 + Math.random() * 20,
                    -1000 + Math.random() * 2000
                );
                scene.add(cloud);
            }
        }
        createClouds();

        // Lane positions for cars
        const lanePositions = [-3.75, -1.25, 1.25, 3.75]; // Centers of the four lanes

        // Traffic cars
        const trafficCars = [];
        const trafficCarCount = 100; // Number of traffic cars

        for (let i = 0; i < trafficCarCount; i++) {
            const trafficCar = createCar(0x00ff00); // Green traffic cars
            const lane = lanePositions[Math.floor(Math.random() * lanePositions.length)];
            const initialZ = Math.random() * 1000 + 50; // Positions ahead of the player
            trafficCar.position.set(
                lane, // Stay in a lane
                0.5,
                initialZ
            );
            trafficCar.userData.speed = 0.1 + Math.random() * 0.3; // Positive speed
            trafficCars.push(trafficCar);
            scene.add(trafficCar);
        }

        // Variables
        let score = 0;
        let gameOver = false;
        let playerSpeed = 0;
        const maxSpeed = 0.6; // Adjusted max speed for player
        const acceleration = 0.01; // Decreased player acceleration
        const deceleration = 0.02; // Adjusted deceleration
        const copMaxSpeed = 0.5; // Max speed for cop car
        const copAcceleration = 0.005; // Decreased cop acceleration
        let copCurrentSpeed = 0; // Initial cop speed

        // Update score
        const scoreboard = document.getElementById('scoreboard');

        // Variables for smoke and rotation
        let currentRotationAngle = 0;
        const maxRotationAngle = Math.PI / 8; // Maximum rotation angle (approx 22.5 degrees)
        const rotationSpeed = 0.05; // How fast the car rotates

        // Smoke particle creation
        function createSmokeParticle(scene) {
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xcccccc, 
                transparent: true, 
                opacity: 0.5 
            });
            const smoke = new THREE.Mesh(geometry, material);
            scene.add(smoke);
            return smoke;
        }

        // Handle keyboard input
        const keys = {};
        document.addEventListener('keydown', (event) => {
            keys[event.key] = true;
        });
        document.addEventListener('keyup', (event) => {
            keys[event.key] = false;
        });

        // Update player car based on keys
        function handleInput() {
            if (!playerCar) {
                setTimeout(handleInput, 16);
                return;
            }

            // Smoke effect for left movement
            if (keys['ArrowLeft']) {
                playerCar.position.x += 0.15; // Move left
                
                // Rotation mechanics
                currentRotationAngle = Math.min(currentRotationAngle + rotationSpeed, maxRotationAngle);
                playerCar.rotation.y = currentRotationAngle;

                // Create smoke particles from rear wheels
                const smokeLeft = createSmokeParticle(scene);
                smokeLeft.position.copy(playerCar.position);
                smokeLeft.position.x -= 0.7; // Left rear wheel position
                smokeLeft.position.z -= 1.3;
                
                const smokeRight = createSmokeParticle(scene);
                smokeRight.position.copy(playerCar.position);
                smokeRight.position.x += 0.7; // Right rear wheel position
                smokeRight.position.z -= 1.3;

                smokeParticles.push(smokeLeft, smokeRight);
            }
            // Smoke effect for right movement
            else if (keys['ArrowRight']) {
                playerCar.position.x -= 0.15; // Move right
                
                // Rotation mechanics
                currentRotationAngle = Math.max(currentRotationAngle - rotationSpeed, -maxRotationAngle);
                playerCar.rotation.y = currentRotationAngle;

                // Create smoke particles from rear wheels
                const smokeLeft = createSmokeParticle(scene);
                smokeLeft.position.copy(playerCar.position);
                smokeLeft.position.x -= 0.7; // Left rear wheel position
                smokeLeft.position.z -= 1.3;
                
                const smokeRight = createSmokeParticle(scene);
                smokeRight.position.copy(playerCar.position);
                smokeRight.position.x += 0.7; // Right rear wheel position
                smokeRight.position.z -= 1.3;

                smokeParticles.push(smokeLeft, smokeRight);
            }
            // Reset rotation when no movement
            else {
                if (currentRotationAngle > 0) {
                    currentRotationAngle = Math.max(currentRotationAngle - rotationSpeed, 0);
                } else if (currentRotationAngle < 0) {
                    currentRotationAngle = Math.min(currentRotationAngle + rotationSpeed, 0);
                }
                playerCar.rotation.y = currentRotationAngle;
            }

            // Manage smoke particles
            smokeParticles.forEach((smoke, index) => {
                smoke.scale.multiplyScalar(1.1); // Grow smoke
                smoke.material.opacity -= 0.05; // Fade out
                
                // Remove smoke if too transparent
                if (smoke.material.opacity <= 0) {
                    scene.remove(smoke);
                    smokeParticles.splice(index, 1);
                }
            });

            // Existing movement and speed logic
            if (keys['ArrowUp']) {
                playerSpeed = Math.min(playerSpeed + acceleration, maxSpeed);
            } else if (keys['ArrowDown']) {
                playerSpeed = Math.max(playerSpeed - acceleration, -maxSpeed / 2);
            } else {
                if (playerSpeed > 0) {
                    playerSpeed = Math.max(playerSpeed - deceleration, 0);
                } else if (playerSpeed < 0) {
                    playerSpeed = Math.min(playerSpeed + deceleration, 0);
                }
            }

            // Update player car position
            playerCar.position.z += playerSpeed;

            // Enforce road boundaries immediately after movement
            if (playerCar.position.x < -roadWidth / 2 + 0.75) playerCar.position.x = -roadWidth / 2 + 0.75;
            if (playerCar.position.x > roadWidth / 2 - 0.75) playerCar.position.x = roadWidth / 2 - 0.75;

            setTimeout(handleInput, 16);
        }

        // Array to hold smoke particles
        const smokeParticles = [];

        // Animation loop
        function animate() {
            if (gameOver || !playerCar) return;

            requestAnimationFrame(animate);

            // Increase cop car speed gradually up to its max speed
            if (copCurrentSpeed < copMaxSpeed) {
                copCurrentSpeed += copAcceleration;
            } else {
                copCurrentSpeed = copMaxSpeed;
            }

            // Move the cop car towards the player
            const copDirection = new THREE.Vector3();
            copDirection.subVectors(playerCar.position, copCar.position).normalize();
            copCar.position.addScaledVector(copDirection, copCurrentSpeed);

            // Move traffic cars
            trafficCars.forEach((trafficCar) => {
                // Move traffic cars along z
                trafficCar.position.z += trafficCar.userData.speed;

                // If traffic car goes behind the player, reset position ahead
                if (trafficCar.position.z < playerCar.position.z - 100) {
                    trafficCar.position.z = playerCar.position.z + 1000 + Math.random() * 500;
                    const lane = lanePositions[Math.floor(Math.random() * lanePositions.length)];
                    trafficCar.position.x = lane;
                    trafficCar.userData.speed = 0.2 + Math.random() * 0.1; // Random speed between 0.2 and 0.3
                }

                // Collision detection with traffic cars
                if (
                    Math.abs(playerCar.position.x - trafficCar.position.x) < 1.2 &&
                    Math.abs(playerCar.position.z - trafficCar.position.z) < 4
                ) {
                    gameOver = true;
                    alert('You crashed into a car! Game Over!');
                }
            });

            // Collision detection with cop car
            const distanceToCop = playerCar.position.distanceTo(copCar.position);
            if (distanceToCop < 2) {
                gameOver = true;
                alert('You were caught by the cops! Game Over!');
            }

            // Loop trees for infinite scrolling
            trees.forEach((tree) => {
                tree.position.z -= playerSpeed; // Move with the player
                if (tree.position.z < playerCar.position.z - 200) {
                    tree.position.z = playerCar.position.z + roadLength / 2;
                }
            });

            // Update camera position to follow the player
            camera.position.set(playerCar.position.x, 5, playerCar.position.z - 10);
            camera.lookAt(playerCar.position);

            // Update score
            score += 1;
            scoreboard.textContent = `Score: ${score}`;

            renderer.render(scene, camera);
        }

        // Start the game when "Start" button is clicked
        document.getElementById('start-button').addEventListener('click', () => {
            if (!modelLoaded) {
                alert('The car model is still loading. Please wait a moment.');
                return;
            }
            document.getElementById('main-menu').style.display = 'none';
            startIntroAnimation();
        });

        // Settings button (no functionality added yet)
        document.getElementById('settings-button').addEventListener('click', () => {
            alert('Settings will be available soon!');
        });

        // Add siren flashing effect
        let sirenOn = false;
        function toggleSiren() {
            sirenOn = !sirenOn;
            siren.material.color.set(sirenOn ? 0xff0000 : 0x000000);
        }

        // Intro animation sequence
        function startIntroAnimation() {
            // Initial camera position (behind the player)
            camera.position.set(playerCar.position.x, 5, playerCar.position.z - 10);
            camera.lookAt(playerCar.position);

            // Create a timeline for the intro animation
            const introTimeline = gsap.timeline({ onComplete: () => {
                // Start the game loop and input handling after the intro
                animate();
                handleInput();
            }});

            // Flip around to show the cop car
            introTimeline.to(camera.position, {
                x: copCar.position.x,
                y: 5,
                z: copCar.position.z - 5,
                duration: 2,
                ease: "power2.inOut",
                onUpdate: function() {
                    camera.lookAt(copCar.position);
                },
                onComplete: function() {
                    // Start siren flashing
                    sirenInterval = setInterval(toggleSiren, 200);
                }
            });

            // Hold on the cop car for a moment
            introTimeline.to({}, { duration: 1 });

            // Cop car starts to move towards the player
            introTimeline.to(copCar.position, {
                z: copCar.position.z + 5, // Move forward a bit
                duration: 2,
                ease: "power2.inOut",
                onUpdate: function() {
                    camera.lookAt(copCar.position);
                }
            }, "-=1"); // Overlap with previous hold

            // Pan back to the player car
            introTimeline.to(camera.position, {
                x: playerCar.position.x,
                y: 5,
                z: playerCar.position.z - 10,
                duration: 2,
                ease: "power2.inOut",
                onUpdate: function() {
                    camera.lookAt(playerCar.position);
                },
                onComplete: function() {
                    // Stop siren flashing
                    clearInterval(sirenInterval);
                    siren.material.color.set(0x000000);
                }
            });

            // Start rendering during the intro
            function renderIntro() {
                renderer.render(scene, camera);
                if (!gameOver) requestAnimationFrame(renderIntro);
            }
            renderIntro();
        }

        // Variable to hold the siren interval
        let sirenInterval;
    </script>
</body>
</html>
