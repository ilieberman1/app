<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Highway Racing Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #scoreboard {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 20px;
            color: black;
            background-color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
        }
        #subtitle {
            position: absolute;
        top: 20px;
        left: 50%; /* Centered */
        transform: translateX(-40%); /* Slightly offset to the left of center */
        color: black;
        font-family: Arial, sans-serif;
        font-size: 48px;
        font-weight: bold;
        text-align: left;
        opacity: 0;
        transition: opacity 0.5s ease-in-out;
        pointer-events: none;
        text-shadow: 
            -2px -2px 0 white,
            2px -2px 0 white,
            -2px 2px 0 white,
            2px 2px 0 white;
        width: 80%; /* Allow width for multiple lines */
        line-height: 1.2; /* Improve line spacing */
        }
    </style>
</head>
<body>
    <!-- Include Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
    <div id="scoreboard">Score: 0</div>
    <div id="subtitle"></div>
    <script>
        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xadd8e6); // Light blue background

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 10, 10);
        scene.add(directionalLight);

        // Define road parameters
        const roadWidth = 10;
        const roadLength = 20000; // Road length

        // Create the road
        const roadGeometry = new THREE.PlaneGeometry(roadWidth, roadLength);
        const roadMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2; // Lay flat
        road.position.z = 0; // Centered at z = 0
        scene.add(road);

        // Speech Recognition Setup
        class SpeechRecognitionManager {
    constructor() {
        this.recognition = null;
        this.subtitleElement = document.getElementById('subtitle');
        this.lastFinalTranscript = '';
        this.initializeSpeechRecognition();
    }

    limitToSixWords(text) {
        // Split text into words
        const words = text.trim().split(/\s+/);
        
        // If more than 6 words, take only the last 6
        if (words.length > 6) {
            return words.slice(-6).join(' ');
        }
        
        return text;
    }

    initializeSpeechRecognition() {
        if ('webkitSpeechRecognition' in window) {
            this.recognition = new webkitSpeechRecognition();
            this.recognition.continuous = true;
            this.recognition.interimResults = true;
            this.recognition.lang = 'en-US';

            this.recognition.onresult = (event) => {
                let finalTranscript = '';
                let interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }

                // Prioritize interim results, strictly limit to 6 words
                const displayText = this.limitToSixWords(
                    interimTranscript.trim() || finalTranscript.trim()
                );
                
                if (displayText) {
                    this.showSubtitle(displayText);
                }

                // Update last final transcript when a new final result is available
                if (finalTranscript.trim() && finalTranscript.trim() !== this.lastFinalTranscript.trim()) {
                    this.lastFinalTranscript = finalTranscript;
                }
            };

            this.recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
            };

            this.recognition.start();
        } else {
            console.warn('Speech recognition not supported');
        }
    }

    showSubtitle(text) {
        // Clear previous timeout if exists
        if (this.fadeTimeout) {
            clearTimeout(this.fadeTimeout);
        }

        // Set the text and make visible
        this.subtitleElement.textContent = text;
        this.subtitleElement.style.opacity = '1';

        // Set a timeout to fade out
        this.fadeTimeout = setTimeout(() => {
            this.subtitleElement.style.opacity = '0';
        }, 3000);
    }
}

        // Instantiate the speech recognition manager
        const speechRecognitionManager = new SpeechRecognitionManager();

        // Add lane lines
        const laneLineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const dashLength = 5;
        const gapLength = 5;
        const totalDashLength = dashLength + gapLength;
        const numberOfDashes = Math.floor(roadLength / totalDashLength);

        const laneLinePositions = [-2.5, 0, 2.5]; // Positions for the lane lines

        laneLinePositions.forEach((xPos) => {
            for (let i = 0; i < numberOfDashes; i++) {
                const zPos = -roadLength / 2 + i * totalDashLength + dashLength / 2;
                const lineGeometry = new THREE.BoxGeometry(0.1, 0.01, dashLength);
                const line = new THREE.Mesh(lineGeometry, laneLineMaterial);
                line.position.set(xPos, 0.01, zPos);
                scene.add(line);
            }
        });

        // Barriers (left and right)
        const barrierMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const leftBarrier = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, roadLength), barrierMaterial);
        const rightBarrier = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, roadLength), barrierMaterial);

        leftBarrier.position.set(-roadWidth / 2 - 0.25, 0.5, 0);
        rightBarrier.position.set(roadWidth / 2 + 0.25, 0.5, 0);
        scene.add(leftBarrier, rightBarrier);

        // Lane positions for cars
        const lanePositions = [-3.75, -1.25, 1.25, 3.75]; // Centers of the four lanes

        // Function to create a car
        function createCar(color) {
            const carGroup = new THREE.Group();

            // Main body
            const bodyGeometry = new THREE.BoxGeometry(1.5, 0.5, 3);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            carGroup.add(body);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 32);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const wheels = [];
            for (let i = 0; i < 4; i++) {
                wheels[i] = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheels[i].rotation.z = Math.PI / 2; // Rotate to lay flat
            }
            wheels[0].position.set(-0.7, 0.3, 1.3); // Front-left
            wheels[1].position.set(0.7, 0.3, 1.3); // Front-right
            wheels[2].position.set(-0.7, 0.3, -1.3); // Back-left
            wheels[3].position.set(0.7, 0.3, -1.3); // Back-right

            wheels.forEach((wheel) => carGroup.add(wheel));

            return carGroup;
        }

        // Create the player car
        const playerCar = createCar(0xff0000);
        playerCar.position.set(0, 0.5, 0); // Start at z = 0
        scene.add(playerCar);

        // Create the cop car
        const copCar = createCar(0x0000ff); // Blue cop car
        copCar.position.set(0, 0.5, -12); // Start behind the player
        scene.add(copCar);

        // Create trees on the sides
        const trees = [];
        const treeGeometry = new THREE.CylinderGeometry(0, 0.5, 1.5, 8);
        const treeMaterial = new THREE.MeshPhongMaterial({ color: 0x228b22 }); // Green color

        for (let i = 0; i < 200; i++) {
            const tree = new THREE.Mesh(treeGeometry, treeMaterial);
            tree.position.set(
                Math.random() > 0.5 ? roadWidth / 2 + 1 + Math.random() * 5 : -roadWidth / 2 - 1 - Math.random() * 5,
                0.75,
                -roadLength / 2 + Math.random() * roadLength
            );
            trees.push(tree);
            scene.add(tree);
        }

        // Traffic cars
        const trafficCars = [];
        const trafficCarCount = 100; // Number of traffic cars

        for (let i = 0; i < trafficCarCount; i++) {
            const trafficCar = createCar(0x00ff00); // Green traffic cars
            const lane = lanePositions[Math.floor(Math.random() * lanePositions.length)];
            const initialZ = Math.random() * 1000 + 50; // Positions ahead of the player
            trafficCar.position.set(
                lane, // Stay in a lane
                0.5,
                initialZ
            );
            trafficCar.userData.speed = 0.1 + Math.random() * 0.3; // Positive speed
            trafficCars.push(trafficCar);
            scene.add(trafficCar);
        }

        // Variables
        let score = 0;
        let gameOver = false;
        let playerSpeed = 0;
        const maxSpeed = 0.6; // Adjusted max speed for player
        const acceleration = 0.01; // Decreased player acceleration
        const deceleration = 0.02; // Adjusted deceleration
        const copMaxSpeed = 0.5; // Max speed for cop car
        const copAcceleration = 0.005; // Decreased cop acceleration
        let copCurrentSpeed = 0; // Initial cop speed

        // Update score
        const scoreboard = document.getElementById('scoreboard');

        // Variables for smoke and tilt
        let currentTiltAngle = 0;
        const maxTiltAngle = Math.PI / 6;
        const tiltSpeed = 0.02;
        const smokeParticles = [];

        // Smoke particle creation
        function createSmokeParticle(scene) {
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xcccccc, 
                transparent: true, 
                opacity: 0.5 
            });
            const smoke = new THREE.Mesh(geometry, material);
            scene.add(smoke);
            return smoke;
        }

        // Handle keyboard input
        const keys = {};
        document.addEventListener('keydown', (event) => {
            keys[event.key] = true;
        });
        document.addEventListener('keyup', (event) => {
            keys[event.key] = false;
        });

        // Update player car based on keys
        function handleInput() {
            // Smoke effect for left movement
            if (keys['ArrowLeft']) {
                playerCar.position.x += 0.15; // Move left
                
                // Tilt mechanics
                currentTiltAngle = Math.min(currentTiltAngle + tiltSpeed, maxTiltAngle);
                playerCar.rotation.z = -currentTiltAngle;
                playerCar.rotation.y = -currentTiltAngle / 2;

                // Create smoke particles from rear wheels
                const smokeLeft = createSmokeParticle(scene);
                smokeLeft.position.copy(playerCar.position);
                smokeLeft.position.x -= 0.7; // Left rear wheel position
                smokeLeft.position.z -= 1.3;
                
                const smokeRight = createSmokeParticle(scene);
                smokeRight.position.copy(playerCar.position);
                smokeRight.position.x += 0.7; // Right rear wheel position
                smokeRight.position.z -= 1.3;

                smokeParticles.push(smokeLeft, smokeRight);
            }
            // Smoke effect for right movement
            else if (keys['ArrowRight']) {
                playerCar.position.x -= 0.15; // Move right
                
                // Tilt mechanics
                currentTiltAngle = Math.min(currentTiltAngle + tiltSpeed, maxTiltAngle);
                playerCar.rotation.z = currentTiltAngle;
                playerCar.rotation.y = currentTiltAngle / 2;

                // Create smoke particles from rear wheels
                const smokeLeft = createSmokeParticle(scene);
                smokeLeft.position.copy(playerCar.position);
                smokeLeft.position.x -= 0.7; // Left rear wheel position
                smokeLeft.position.z -= 1.3;
                
                const smokeRight = createSmokeParticle(scene);
                smokeRight.position.copy(playerCar.position);
                smokeRight.position.x += 0.7; // Right rear wheel position
                smokeRight.position.z -= 1.3;

                smokeParticles.push(smokeLeft, smokeRight);
            }
            // Reset position when no movement
            else {
                if (currentTiltAngle > 0) {
                    currentTiltAngle = Math.max(currentTiltAngle - tiltSpeed, 0);
                    playerCar.rotation.z = 0;
                    playerCar.rotation.y = 0;
                }
            }

            // Manage smoke particles
            smokeParticles.forEach((smoke, index) => {
                smoke.scale.multiplyScalar(1.1); // Grow smoke
                smoke.material.opacity -= 0.05; // Fade out
                
                // Remove smoke if too transparent
                if (smoke.material.opacity <= 0) {
                    scene.remove(smoke);
                    smokeParticles.splice(index, 1);
                }
            });

            // Existing movement and speed logic
            if (keys['ArrowUp']) {
                playerSpeed = Math.min(playerSpeed + acceleration, maxSpeed);
            } else if (keys['ArrowDown']) {
                playerSpeed = Math.max(playerSpeed - acceleration, -maxSpeed / 2);
            } else {
                if (playerSpeed > 0) {
                    playerSpeed = Math.max(playerSpeed - deceleration, 0);
                } else if (playerSpeed < 0) {
                    playerSpeed = Math.min(playerSpeed + deceleration, 0);
                }
            }

            // Update player car position
            playerCar.position.z += playerSpeed;

            // Enforce road boundaries immediately after movement
            if (playerCar.position.x < -roadWidth / 2 + 0.75) playerCar.position.x = -roadWidth / 2 + 0.75;
            if (playerCar.position.x > roadWidth / 2 - 0.75) playerCar.position.x = roadWidth / 2 - 0.75;

            setTimeout(handleInput, 16);
        }
        handleInput();

        // Animation loop
        function animate() {
            if (gameOver) return;

            requestAnimationFrame(animate);

            // Increase cop car speed gradually up to its max speed
            if (copCurrentSpeed < copMaxSpeed) {
                copCurrentSpeed += copAcceleration;
            } else {
                copCurrentSpeed = copMaxSpeed;
            }

            // Move the cop car towards the player
            const copDirection = new THREE.Vector3();
            copDirection.subVectors(playerCar.position, copCar.position).normalize();
            copCar.position.addScaledVector(copDirection, copCurrentSpeed);

            // Move traffic cars
            trafficCars.forEach((trafficCar) => {
                // Move traffic cars along z
                trafficCar.position.z += trafficCar.userData.speed;

                // If traffic car goes behind the player, reset position ahead
                if (trafficCar.position.z < playerCar.position.z - 100) {
                    trafficCar.position.z = playerCar.position.z + 1000 + Math.random() * 500;
                    const lane = lanePositions[Math.floor(Math.random() * lanePositions.length)];
                    trafficCar.position.x = lane;
                    trafficCar.userData.speed = 0.2 + Math.random() * 0.1; // Random speed between 0.4 and 0.8
                }

                // Collision detection with traffic cars
                if (
                    Math.abs(playerCar.position.x - trafficCar.position.x) < 1.2 &&
                    Math.abs(playerCar.position.z - trafficCar.position.z) < 4
                ) {
                    gameOver = true;
                    alert('You crashed into a car! Game Over!');
                }
            });

            // Collision detection with cop car
            const distanceToCop = playerCar.position.distanceTo(copCar.position);
            if (distanceToCop < 2) {
                gameOver = true;
                alert('You were caught by the cops! Game Over!');
            }

            // Loop trees for infinite scrolling
            trees.forEach((tree) => {
                tree.position.z -= playerSpeed; // Move with the player
                if (tree.position.z < playerCar.position.z - 200) {
                    tree.position.z = playerCar.position.z + roadLength / 2;
                }
            });

            // Update camera position to follow the player
            camera.position.set(playerCar.position.x, 5, playerCar.position.z - 10);
            camera.lookAt(playerCar.position);

            // Update score
            score += 1;
            scoreboard.textContent = `Score: ${score}`;

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
