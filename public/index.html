<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Escape the Cop</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #scoreboard {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 20px;
            color: black;
            background-color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            z-index: 1;
        }
        #subtitle {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 36px;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            pointer-events: none;
            text-shadow: 
                -2px -2px 0 black,
                2px -2px 0 black,
                -2px 2px 0 black,
                2px 2px 0 black;
            width: 80%;
            line-height: 1.2;
            z-index: 2;
            word-wrap: break-word;
        }
        /* Main Menu Styles */
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #add8e6;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }
        #game-title {
            font-size: 48px;
            margin-bottom: 40px;
            font-family: Arial, sans-serif;
            color: black;
        }
        #car-images {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 40px;
        }
        .car-image {
            width: 100px;
            height: 50px;
            margin: 0 50px;
            position: relative;
            background-color: transparent;
        }
        /* Car Shape Styles */
        .car-body {
            width: 100px;
            height: 30px;
            background-color: currentColor;
            position: relative;
            border-radius: 5px;
        }
        .car-top {
            width: 60px;
            height: 20px;
            background-color: currentColor;
            position: absolute;
            top: -20px;
            left: 20px;
            border-radius: 5px 5px 0 0;
        }
        .wheel {
            width: 20px;
            height: 20px;
            background-color: black;
            border-radius: 50%;
            position: absolute;
            bottom: -10px;
        }
        .wheel.left {
            left: 15px;
        }
        .wheel.right {
            right: 15px;
        }
        /* Cop car styles */
        #cop-car .car-body,
        #cop-car .car-top {
            color: blue;
        }
        /* User car styles */
        #user-car .car-body,
        #user-car .car-top {
            color: red;
        }
        #start-button {
            font-size: 36px;
            padding: 15px 30px;
            margin-bottom: 20px;
            cursor: pointer;
        }
        #settings-button {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 18px;
            padding: 10px 20px;
            cursor: pointer;
        }
        /* Loading Screen Styles */
        #loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3;
            display: none; /* Hidden initially */
        }
        /* Settings Menu Styles */
        #settings-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #add8e6;
            padding: 20px;
            border-radius: 5px;
            display: none;
            z-index: 4;
            font-family: Arial, sans-serif;
            text-align: center;
        }
        #settings-menu h2 {
            margin-top: 0;
        }
        #settings-menu label {
            font-size: 24px;
            display: block;
            margin-bottom: 20px;
        }
        #settings-menu button {
            font-size: 24px;
            padding: 10px 20px;
            cursor: pointer;
        }
    </style>
    <!-- Import map to resolve module specifiers -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.152.0/build/three.module.js",
            "three/examples/jsm/loaders/FBXLoader.js": "https://unpkg.com/three@0.152.0/examples/jsm/loaders/FBXLoader.js",
            "three/examples/jsm/objects/Sky.js": "https://unpkg.com/three@0.152.0/examples/jsm/objects/Sky.js",
            "gsap": "https://unpkg.com/gsap@3.11.4/index.js"
        }
    }
    </script>
</head>
<body>
    <!-- Main Menu -->
    <div id="main-menu">
        <h1 id="game-title">Escape the Cop</h1>
        <div id="car-images">
            <div id="cop-car" class="car-image">
                <div class="car-body"></div>
                <div class="car-top"></div>
                <div class="wheel left"></div>
                <div class="wheel right"></div>
            </div>
            <div id="user-car" class="car-image">
                <div class="car-body"></div>
                <div class="car-top"></div>
                <div class="wheel left"></div>
                <div class="wheel right"></div>
            </div>
        </div>
        <!-- Disable the Start button initially -->
        <button id="start-button" disabled>Start</button>
        <button id="settings-button">Settings</button>
    </div>
    <div id="scoreboard">Score: 0</div>
    <div id="subtitle"></div>
    <div id="loading-screen">Loading... 0%</div>

    <!-- Settings Menu -->
    <div id="settings-menu">
        <h2>Settings</h2>
        <label>
            <input type="checkbox" id="subtitles-toggle" checked>
            Subtitles
        </label>
        <button id="close-settings-button">Close</button>
    </div>

    <!-- Your JavaScript code -->
    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';
        import { Sky } from 'three/examples/jsm/objects/Sky.js';
        import gsap from 'gsap';

        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();

        // Set the background color to light sky blue
        scene.background = new THREE.Color(0x87ceeb); // Light blue background

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        // Add a sun (Directional Light)
        const sunLight = new THREE.DirectionalLight(0xffddaa, 1);
        sunLight.position.set(-50, 100, -50);
        scene.add(sunLight);

        // Sun object for visual representation
        const sunMesh = new THREE.Mesh(
            new THREE.CircleGeometry(20, 32),
            new THREE.MeshBasicMaterial({ color: 0xffddaa, side: THREE.DoubleSide })
        );
        sunMesh.position.set(-100, 100, -100);
        scene.add(sunMesh);

        // Optional: Add a procedural sky
        function createProceduralSky() {
            const sky = new Sky();
            sky.scale.setScalar(450000);
            scene.add(sky);

            const skyUniforms = sky.material.uniforms;

            skyUniforms['turbidity'].value = 10;
            skyUniforms['rayleigh'].value = 2;
            skyUniforms['mieCoefficient'].value = 0.005;
            skyUniforms['mieDirectionalG'].value = 0.8;

            const sunParameters = {
                elevation: 20,
                azimuth: 180
            };

            const phi = THREE.MathUtils.degToRad(90 - sunParameters.elevation);
            const theta = THREE.MathUtils.degToRad(sunParameters.azimuth);

            sunLight.position.setFromSphericalCoords(1, phi, theta);

            sky.material.uniforms['sunPosition'].value.copy(sunLight.position);
        }
        createProceduralSky();

        // Define road parameters
        const roadWidth = 10;
        const roadLength = 20000; // Road length

        // Create the road
        const roadGeometry = new THREE.PlaneGeometry(roadWidth, roadLength);
        const roadMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
        const road = new THREE.Mesh(roadGeometry, roadMaterial);
        road.rotation.x = -Math.PI / 2; // Lay flat
        road.position.z = 0; // Centered at z = 0
        scene.add(road);

        // Add highway lines
        function createHighwayLines() {
            const lineGroup = new THREE.Group();
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const lineWidth = 0.1;
            const lineLength = 5;
            const gapBetweenLines = 5;
            const numberOfLines = Math.ceil(roadLength / (lineLength + gapBetweenLines));
            const lanePositions = [-roadWidth / 4, 0, roadWidth / 4];

            lanePositions.forEach((xPos) => {
                for (let i = 0; i < numberOfLines; i++) {
                    const lineGeometry = new THREE.PlaneGeometry(lineWidth, lineLength);
                    const line = new THREE.Mesh(lineGeometry, lineMaterial);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(xPos, 0.01, -roadLength / 2 + i * (lineLength + gapBetweenLines));
                    lineGroup.add(line);
                }
            });
            scene.add(lineGroup);
        }
        createHighwayLines();

        // Add barriers
        function createBarriers() {
            const barrierGroup = new THREE.Group();
            const barrierGeometry = new THREE.BoxGeometry(0.2, 1, 5);
            const barrierMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const numberOfBarriers = Math.ceil(roadLength / 5);
            const positions = [-roadWidth / 2 - 0.5, roadWidth / 2 + 0.5];

            positions.forEach((xPos) => {
                for (let i = 0; i < numberOfBarriers; i++) {
                    const barrier = new THREE.Mesh(barrierGeometry, barrierMaterial);
                    barrier.position.set(xPos, 0.5, -roadLength / 2 + i * 5);
                    barrierGroup.add(barrier);
                }
            });
            scene.add(barrierGroup);
        }
        createBarriers();

        // Loading Screen Elements
        const loadingScreen = document.getElementById('loading-screen');
        const mainMenu = document.getElementById('main-menu');
        const startButton = document.getElementById('start-button');

        // Show loading screen
        loadingScreen.style.display = 'flex';

        // Create the player car (Porsche model)
        const fbxLoader = new FBXLoader();
        let playerCar;
        let modelLoaded = false;

        fbxLoader.load(
            'porsche.fbx', // Adjust path as needed
            (object) => {
                playerCar = object;

                // Adjust scale to match traffic cars
                playerCar.scale.set(0.02, 0.02, 0.02); // Increased scale

                // Adjust position to sit on the road
                playerCar.position.set(0, 0.5, 0); // Adjusted Y position

                // Adjust rotation if necessary
                //playerCar.rotation.y = Math.PI; // Rotate 180 degrees if model faces backward

                scene.add(playerCar);
                modelLoaded = true;

                // Enable Start button and hide loading screen
                startButton.disabled = false;
                loadingScreen.style.display = 'none';
                mainMenu.style.display = 'flex';
            },
            // Progress function
            (xhr) => {
                if (xhr.lengthComputable) {
                    const percentComplete = (xhr.loaded / xhr.total) * 100;
                    console.log(`Loading model: ${Math.round(percentComplete)}%`);
                    loadingScreen.textContent = 'Loading... ' + Math.round(percentComplete) + '%';
                }
            },
            // Error function
            (error) => {
                console.error('Error loading the Porsche model:', error);
                loadingScreen.textContent = `Error loading model: ${error.message}. Please check the file path.`;
            }
        );

        // Create the cop car
        function createCar(color) {
            const carGroup = new THREE.Group();

            // Main body
            const bodyGeometry = new THREE.BoxGeometry(1.5, 0.5, 3);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            carGroup.add(body);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 32);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const wheels = [];
            for (let i = 0; i < 4; i++) {
                wheels[i] = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheels[i].rotation.z = Math.PI / 2; // Rotate to lay flat
            }
            wheels[0].position.set(-0.7, 0.3, 1.3); // Front-left
            wheels[1].position.set(0.7, 0.3, 1.3); // Front-right
            wheels[2].position.set(-0.7, 0.3, -1.3); // Back-left
            wheels[3].position.set(0.7, 0.3, -1.3); // Back-right

            wheels.forEach((wheel) => carGroup.add(wheel));

            return carGroup;
        }

        const copCar = createCar(0x0000ff); // Blue cop car
        copCar.position.set(0, 0.5, -15); // Start closer behind the player
        scene.add(copCar);

        // Add siren light to the cop car
        const siren = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 0.2, 0.2),
            new THREE.MeshBasicMaterial({ color: 0x000000 })
        );
        siren.position.set(0, 1, 0);
        copCar.add(siren);

        // Create trees on the sides
        const trees = [];
        const treeGeometry = new THREE.ConeGeometry(0.5, 2, 8);
        const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
        const treeMaterial = new THREE.MeshPhongMaterial({ color: 0x228b22 }); // Green color
        const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 }); // Brown color

        for (let i = 0; i < 500; i++) {
            const tree = new THREE.Group();

            const leaves = new THREE.Mesh(treeGeometry, treeMaterial);
            leaves.position.y = 1.5;
            tree.add(leaves);

            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.5;
            tree.add(trunk);

            tree.position.set(
                Math.random() > 0.5 ? roadWidth / 2 + 2 + Math.random() * 10 : -roadWidth / 2 - 2 - Math.random() * 10,
                0,
                -roadLength / 2 + Math.random() * roadLength
            );
            trees.push(tree);
            scene.add(tree);
        }

        // Add mountain on the left side
        const mountainGeometry = new THREE.ConeGeometry(50, 100, 32);
        const mountainMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
        const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
        scene.add(mountain);

        // Infinite Clouds
        const cloudGeometry = new THREE.SphereGeometry(5, 32, 32);
        const cloudMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
        const clouds = [];

        function createCloud() {
            const cloud = new THREE.Group();

            const puff1 = new THREE.Mesh(cloudGeometry, cloudMaterial);
            const puff2 = new THREE.Mesh(cloudGeometry, cloudMaterial);
            const puff3 = new THREE.Mesh(cloudGeometry, cloudMaterial);

            puff1.position.set(-2, 0, 0);
            puff2.position.set(2, 0, 0);
            puff3.position.set(0, 1.5, 0);

            cloud.add(puff1);
            cloud.add(puff2);
            cloud.add(puff3);

            cloud.scale.setScalar(1 + Math.random() * 2);
            cloud.position.set(
                -200 + Math.random() * 400,
                30 + Math.random() * 20,
                playerCar ? playerCar.position.z - 500 + Math.random() * 1000 : -500 + Math.random() * 1000
            );

            scene.add(cloud);
            clouds.push(cloud);
        }

        // Spawn initial clouds
        for (let i = 0; i < 50; i++) {
            createCloud();
        }

        // Lane positions for cars
        const lanePositions = [-3.75, -1.25, 1.25, 3.75]; // Centers of the four lanes

        // Traffic Car Class
        class TrafficCar {
            constructor() {
                this.mesh = createCar(0x00ff00); // Green traffic car
                this.lane = lanePositions[Math.floor(Math.random() * lanePositions.length)];
                this.mesh.position.set(
                    this.lane,
                    0.5,
                    playerCar ? playerCar.position.z + 500 + Math.random() * 1000 : Math.random() * 1000 + 50
                );
                this.speed = 0.1 + Math.random() * 0.3; // Random speed between 0.2 and 0.4
                this.targetLane = this.lane;
                this.laneChangeCooldown = 0; // Cooldown before next lane change
                this.turnSignal = null; // Direction of turn signal ('left' or 'right')
                scene.add(this.mesh);
            }

            update(deltaTime) {
                // Move forward
                this.mesh.position.z += this.speed * deltaTime;

                // Lane changing logic
                if (this.laneChangeCooldown <= 0 && Math.random() < 0.005) {
                    // Decide to change lanes
                    const currentLaneIndex = lanePositions.indexOf(this.lane);
                    const direction = Math.random() < 0.5 ? -1 : 1; // -1 for left, 1 for right
                    const newLaneIndex = currentLaneIndex + direction;
                    if (newLaneIndex >= 0 && newLaneIndex < lanePositions.length) {
                        this.targetLane = lanePositions[newLaneIndex];
                        this.turnSignal = direction === -1 ? 'left' : 'right';
                        this.laneChangeCooldown = 200; // Cooldown before next lane change
                    }
                }

                // Apply lane change
                if (this.lane !== this.targetLane) {
                    const laneDiff = this.targetLane - this.lane;
                    const shift = Math.sign(laneDiff) * 0.05 * deltaTime;
                    this.mesh.position.x += shift;
                    this.lane += shift;
                    if (Math.abs(this.lane - this.targetLane) < 0.1) {
                        this.lane = this.targetLane;
                        this.mesh.position.x = this.targetLane;
                        this.turnSignal = null; // Turn off signal after lane change
                    }
                } else {
                    this.turnSignal = null;
                }

                // Update turn signals
                this.updateTurnSignals();

                // Reduce cooldown
                if (this.laneChangeCooldown > 0) {
                    this.laneChangeCooldown -= deltaTime;
                }

                // Collision avoidance with other traffic cars
                trafficCars.forEach((otherCar) => {
                    if (otherCar !== this) {
                        const distance = this.mesh.position.distanceTo(otherCar.mesh.position);
                        if (distance < 5 && this.mesh.position.z > otherCar.mesh.position.z) {
                            // Slow down to avoid collision
                            this.speed = Math.max(this.speed - 0.01 * deltaTime, 0.1);
                        }
                    }
                });

                // Avoid collision with the player car
                const distanceToPlayer = this.mesh.position.distanceTo(playerCar.position);
                if (this.mesh.position.z < playerCar.position.z && distanceToPlayer < 10) {
                    // Player is in front, adjust speed
                    if (distanceToPlayer < 5) {
                        // Slow down more aggressively if very close
                        this.speed = Math.max(this.speed - 0.05 * deltaTime, 0);
                    } else {
                        this.speed = Math.max(this.speed - 0.02 * deltaTime, 0.1);
                    }
                } else {
                    // Speed up if not near the player
                    this.speed = Math.min(this.speed + 0.01 * deltaTime, 0.4);
                }

                // Reset position if behind player
                if (this.mesh.position.z > playerCar.position.z + 200) {
                    this.mesh.position.z = playerCar.position.z - 1000 - Math.random() * 500;
                    this.lane = lanePositions[Math.floor(Math.random() * lanePositions.length)];
                    this.targetLane = this.lane;
                    this.mesh.position.x = this.lane;
                    this.speed = 0.2 + Math.random() * 0.2;
                }
            }

            updateTurnSignals() {
                if (!this.turnSignal) {
                    // Remove existing signals
                    if (this.leftSignal) {
                        this.mesh.remove(this.leftSignal);
                        this.leftSignal = null;
                    }
                    if (this.rightSignal) {
                        this.mesh.remove(this.rightSignal);
                        this.rightSignal = null;
                    }
                    return;
                }

                const signalColor = 0xffff00; // Yellow color for turn signals
                const signalGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.1);
                const signalMaterial = new THREE.MeshBasicMaterial({ color: signalColor });

                if (this.turnSignal === 'left') {
                    if (!this.leftSignal) {
                        this.leftSignal = new THREE.Mesh(signalGeometry, signalMaterial);
                        this.leftSignal.position.set(-0.8, 0.5, -1.5);
                        this.mesh.add(this.leftSignal);
                    }
                } else if (this.turnSignal === 'right') {
                    if (!this.rightSignal) {
                        this.rightSignal = new THREE.Mesh(signalGeometry, signalMaterial);
                        this.rightSignal.position.set(0.8, 0.5, -1.5);
                        this.mesh.add(this.rightSignal);
                    }
                }
            }
        }

        // Create traffic cars
        const trafficCars = [];
        const trafficCarCount = 30; // Reduced number of traffic cars for better performance

        for (let i = 0; i < trafficCarCount; i++) {
            const trafficCar = new TrafficCar();
            trafficCars.push(trafficCar);
        }

        // Variables
        let score = 0;
        let gameOver = false;
        let playerSpeed = 0;
        const maxSpeed = 0.6; // Adjusted max speed for player
        const acceleration = 0.01; // Decreased player acceleration
        const deceleration = 0.02; // Adjusted deceleration
        const copMaxSpeed = 0.5; // Max speed for cop car
        const copAcceleration = 0.005; // Decreased cop acceleration
        let copCurrentSpeed = 0; // Initial cop speed

        // Update score
        const scoreboard = document.getElementById('scoreboard');

        // Variables for smoke and rotation
        let currentRotationAngle = 0;
        const maxRotationAngle = Math.PI / 8; // Maximum rotation angle (approx 22.5 degrees)
        const rotationSpeed = 0.05; // How fast the car rotates

        // Load smoke texture
        const textureLoader = new THREE.TextureLoader();
        const smokeTexture = textureLoader.load('smoke.png'); // Provide a smoke texture image in your project directory

        // Array to hold smoke particles
        const smokeParticles = [];

        // Smoke particle creation
        function createSmokeParticle(position) {
            const material = new THREE.SpriteMaterial({
                map: smokeTexture,
                transparent: true,
                opacity: 0.5,
                depthWrite: false,
                depthTest: false,
                blending: THREE.AdditiveBlending
            });
            const smoke = new THREE.Sprite(material);
            smoke.position.copy(position);
            smoke.scale.set(1, 1, 1);
            scene.add(smoke);
            return smoke;
        }

        // Handle keyboard input
        const keys = {};
        document.addEventListener('keydown', (event) => {
            keys[event.key] = true;
        });
        document.addEventListener('keyup', (event) => {
            keys[event.key] = false;
        });

        // Subtitles
        let subtitlesEnabled = true;
        const subtitleElement = document.getElementById('subtitle');

        // Speech Recognition Setup
        let recognition;
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true; // Use interim results for real-time updates
            recognition.lang = 'en-US';
        } else {
            console.warn('Speech Recognition API not supported in this browser.');
        }

        // Start Speech Recognition
        function startSpeechRecognition() {
            if (!recognition) return;
            recognition.start();
            recognition.onresult = (event) => {
                if (subtitlesEnabled) {
                    let transcript = '';
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        transcript += event.results[i][0].transcript;
                    }
                    // Limit to last 6 words
                    const words = transcript.trim().split(/\s+/);
                    const lastWords = words.slice(-6).join(' ');
                    subtitleElement.textContent = lastWords;
                    subtitleElement.style.opacity = 1;
                }
            };
            recognition.onerror = (event) => {
                console.error('Speech Recognition Error:', event.error);
            };
        }

        function stopSpeechRecognition() {
            if (recognition) {
                recognition.stop();
            }
        }

        // Settings Menu Logic
        document.getElementById('settings-button').addEventListener('click', () => {
            document.getElementById('settings-menu').style.display = 'block';
        });

        document.getElementById('close-settings-button').addEventListener('click', () => {
            document.getElementById('settings-menu').style.display = 'none';
        });

        document.getElementById('subtitles-toggle').addEventListener('change', (event) => {
            subtitlesEnabled = event.target.checked;
            if (subtitlesEnabled) {
                // Request microphone permission
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then((stream) => {
                        startSpeechRecognition();
                        // We don't need the stream, so stop it
                        stream.getTracks().forEach(track => track.stop());
                    })
                    .catch((err) => {
                        console.error('Microphone access denied:', err);
                        alert('Microphone access is required for subtitles.');
                        event.target.checked = false;
                        subtitlesEnabled = false;
                    });
            } else {
                stopSpeechRecognition();
                subtitleElement.style.opacity = 0;
                subtitleElement.textContent = '';
            }
        });

        // Start speech recognition if subtitles are enabled
        if (subtitlesEnabled) {
            // Request microphone permission
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then((stream) => {
                    startSpeechRecognition();
                    // We don't need the stream, so stop it
                    stream.getTracks().forEach(track => track.stop());
                })
                .catch((err) => {
                    console.error('Microphone access denied:', err);
                    subtitlesEnabled = false;
                });
        }

        // Update player car based on keys
        function handleInput() {
            if (!playerCar) {
                setTimeout(handleInput, 16);
                return;
            }

            // Smoke effect for left movement
            if (keys['ArrowLeft']) {
                playerCar.position.x += 0.15; // Move left
                
                // Rotation mechanics
                currentRotationAngle = Math.min(currentRotationAngle + rotationSpeed, maxRotationAngle);
                playerCar.rotation.y = currentRotationAngle;

                // Create smoke particles from rear wheels
                const leftWheelPos = new THREE.Vector3(-0.7, 0.2, -1.3);
                const rightWheelPos = new THREE.Vector3(0.7, 0.2, -1.3);

                playerCar.localToWorld(leftWheelPos);
                playerCar.localToWorld(rightWheelPos);

                const smokeLeft = createSmokeParticle(leftWheelPos);
                const smokeRight = createSmokeParticle(rightWheelPos);

                smokeParticles.push({ sprite: smokeLeft, velocity: new THREE.Vector3(0, 0.05, -0.1), life: 100 });
                smokeParticles.push({ sprite: smokeRight, velocity: new THREE.Vector3(0, 0.05, -0.1), life: 100 });
            }
            // Smoke effect for right movement
            else if (keys['ArrowRight']) {
                playerCar.position.x -= 0.15; // Move right
                
                // Rotation mechanics
                currentRotationAngle = Math.max(currentRotationAngle - rotationSpeed, -maxRotationAngle);
                playerCar.rotation.y = currentRotationAngle;

                // Create smoke particles from rear wheels
                const leftWheelPos = new THREE.Vector3(-0.7, 0.2, -1.3);
                const rightWheelPos = new THREE.Vector3(0.7, 0.2, -1.3);

                playerCar.localToWorld(leftWheelPos);
                playerCar.localToWorld(rightWheelPos);

                const smokeLeft = createSmokeParticle(leftWheelPos);
                const smokeRight = createSmokeParticle(rightWheelPos);

                smokeParticles.push({ sprite: smokeLeft, velocity: new THREE.Vector3(0, 0.05, -0.1), life: 100 });
                smokeParticles.push({ sprite: smokeRight, velocity: new THREE.Vector3(0, 0.05, -0.1), life: 100 });
            }
            // Reset rotation when no movement
            else {
                if (currentRotationAngle > 0) {
                    currentRotationAngle = Math.max(currentRotationAngle - rotationSpeed, 0);
                } else if (currentRotationAngle < 0) {
                    currentRotationAngle = Math.min(currentRotationAngle + rotationSpeed, 0);
                }
                playerCar.rotation.y = currentRotationAngle;
            }

            // Existing movement and speed logic
            if (keys['ArrowUp']) {
                playerSpeed = Math.min(playerSpeed + acceleration, maxSpeed);
            } else if (keys['ArrowDown']) {
                playerSpeed = Math.max(playerSpeed - acceleration, -maxSpeed / 2);
            } else {
                if (playerSpeed > 0) {
                    playerSpeed = Math.max(playerSpeed - deceleration, 0);
                } else if (playerSpeed < 0) {
                    playerSpeed = Math.min(playerSpeed + deceleration, 0);
                }
            }

            // Update player car position
            playerCar.position.z += playerSpeed;

            // Enforce road boundaries immediately after movement
            if (playerCar.position.x < -roadWidth / 2 + 0.75) playerCar.position.x = -roadWidth / 2 + 0.75;
            if (playerCar.position.x > roadWidth / 2 - 0.75) playerCar.position.x = roadWidth / 2 - 0.75;

            setTimeout(handleInput, 16);
        }

        // Animation loop
        function animate() {
            if (gameOver || !playerCar) return;

            requestAnimationFrame(animate);

            let currentTime = performance.now();
            const deltaTime = 1; // You can adjust this value or calculate actual deltaTime if needed

            // Increase cop car speed gradually up to its max speed
            if (copCurrentSpeed < copMaxSpeed) {
                copCurrentSpeed += copAcceleration;
            } else {
                copCurrentSpeed = copMaxSpeed;
            }

            // Move the cop car towards the player
            const copDirection = new THREE.Vector3();
            copDirection.subVectors(playerCar.position, copCar.position).normalize();
            copCar.position.addScaledVector(copDirection, copCurrentSpeed);

            // Update traffic cars
            trafficCars.forEach((trafficCar) => {
                trafficCar.update(deltaTime);

                // Collision detection with player car
                if (
                    Math.abs(playerCar.position.x - trafficCar.mesh.position.x) < 1.2 &&
                    Math.abs(playerCar.position.z - trafficCar.mesh.position.z) < 4
                ) {
                    gameOver = true;
                    alert('You crashed into a car! Game Over!');
                    stopSpeechRecognition();
                }
            });

            // Collision detection with cop car
            const distanceToCop = playerCar.position.distanceTo(copCar.position);
            if (distanceToCop < 2) {
                gameOver = true;
                alert('You were caught by the cops! Game Over!');
                stopSpeechRecognition();
            }

            // Loop trees for infinite scrolling
            trees.forEach((tree) => {
                tree.position.z -= playerSpeed; // Move with the player
                if (tree.position.z < playerCar.position.z - 200) {
                    tree.position.z = playerCar.position.z + roadLength / 2;
                }
            });

            // Update smoke particles
            smokeParticles.forEach((particle, index) => {
                particle.sprite.position.add(particle.velocity);
                particle.sprite.material.opacity -= 0.005;
                particle.sprite.scale.multiplyScalar(1.01);
                particle.life -= 1;

                if (particle.life <= 0 || particle.sprite.material.opacity <= 0) {
                    scene.remove(particle.sprite);
                    smokeParticles.splice(index, 1);
                }
            });

            // Update camera position to follow the player
            camera.position.set(playerCar.position.x, 5, playerCar.position.z - 10);
            camera.lookAt(playerCar.position);

            // Update clouds for infinite scrolling
            clouds.forEach((cloud, index) => {
                cloud.position.z += playerSpeed * 0.5; // Move clouds slower than the player
                if (cloud.position.z > playerCar.position.z + 500) {
                    scene.remove(cloud);
                    clouds.splice(index, 1);
                    createCloud();
                }
            });

            // Update sun and mountain positions
            sunMesh.position.set(
                playerCar.position.x - 50, // Adjust to position sun on the left
                playerCar.position.y + 80, // Adjust to position sun higher in the sky
                playerCar.position.z - 100 // Adjust to position sun ahead
            );

            mountain.position.set(
                playerCar.position.x - 100, // Position mountain on the left
                -50, // Ground level
                playerCar.position.z - 200 // Position mountain ahead
            );

            // Ensure the sun always faces the camera
            sunMesh.lookAt(camera.position);

            // Update score
            score += 1;
            scoreboard.textContent = `Score: ${score}`;

            renderer.render(scene, camera);
        }

        // Start the game when "Start" button is clicked
        document.getElementById('start-button').addEventListener('click', () => {
            if (!modelLoaded) {
                alert('The car model is still loading. Please wait a moment.');
                return;
            }
            document.getElementById('main-menu').style.display = 'none';
            startIntroAnimation();
        });

        // Add siren flashing effect
        let sirenOn = false;
        function toggleSiren() {
            sirenOn = !sirenOn;
            siren.material.color.set(sirenOn ? 0xff0000 : 0x000000);
        }

        // Intro animation sequence
        function startIntroAnimation() {
            // Initial camera position (behind the player)
            camera.position.set(playerCar.position.x, 5, playerCar.position.z - 10);
            camera.lookAt(playerCar.position);

            // Create a timeline for the intro animation
            const introTimeline = gsap.timeline({
                onComplete: () => {
                    // Start the game loop and input handling after the intro
                    animate();
                    handleInput();
                    // Start speech recognition if subtitles are enabled
                    if (subtitlesEnabled) {
                        startSpeechRecognition();
                    }
                }
            });

            // Flip around to show the cop car
            introTimeline.to(camera.position, {
                x: copCar.position.x,
                y: 5,
                z: copCar.position.z - 5,
                duration: 2,
                ease: "power2.inOut",
                onUpdate: function() {
                    camera.lookAt(copCar.position);
                },
                onStart: function() {
                    if (subtitlesEnabled) {
                        subtitleElement.textContent = "Officer: We've got you now!";
                        subtitleElement.style.opacity = 1;
                    }
                },
                onComplete: function() {
                    // Start siren flashing
                    sirenInterval = setInterval(toggleSiren, 200);
                }
            });

            // Hold on the cop car for a moment
            introTimeline.to({}, {
                duration: 1,
                onStart: function() {
                    if (subtitlesEnabled) {
                        subtitleElement.textContent = "You: Not if I can help it!";
                    }
                }
            });

            // Cop car starts to move towards the player
            introTimeline.to(copCar.position, {
                z: copCar.position.z + 5, // Move forward a bit
                duration: 2,
                ease: "power2.inOut",
                onUpdate: function() {
                    camera.lookAt(copCar.position);
                },
                onStart: function() {
                    if (subtitlesEnabled) {
                        subtitleElement.textContent = "";
                        subtitleElement.style.opacity = 0;
                    }
                }
            }, "-=1"); // Overlap with previous hold

            // Pan back to the player car
            introTimeline.to(camera.position, {
                x: playerCar.position.x,
                y: 5,
                z: playerCar.position.z - 10,
                duration: 2,
                ease: "power2.inOut",
                onUpdate: function() {
                    camera.lookAt(playerCar.position);
                },
                onComplete: function() {
                    // Stop siren flashing
                    clearInterval(sirenInterval);
                    siren.material.color.set(0x000000);
                    // Hide subtitle if subtitles are disabled
                    if (!subtitlesEnabled) {
                        subtitleElement.style.opacity = 0;
                    }
                }
            });

            // Start rendering during the intro
            function renderIntro() {
                renderer.render(scene, camera);
                if (!gameOver) requestAnimationFrame(renderIntro);
            }
            renderIntro();
        }

        // Variable to hold the siren interval
        let sirenInterval;
    </script>
</body>
</html>
